/*
 * Copyright 2020-2020 Exactpro (Exactpro Systems Limited)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

import "th2_grpc_common/common.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/empty.proto";

option java_multiple_files = true;
option java_package = "com.exactpro.th2.dataprovider.grpc";


service DataProvider {

  /* returns a single event with the specified id */
  rpc getEvent (EventID) returns (EventData) {
  }

  /* returns a single message with the specified id */
  rpc getMessage (MessageID) returns (MessageData) {
  }

  /* returns a list of message stream names */
  rpc getMessageStreams (google.protobuf.Empty) returns (StringList) {
  }

  /* Creates a message stream that matches the filter. */

  rpc searchMessages (MessageSearchRequest) returns (stream StreamResponse) {

  }

  /* Create a stream of event or event metadata that matches the filter. */
  rpc searchEvents (EventSearchRequest) returns (stream StreamResponse) {

  }

  /* gets all the names of sse message filters */

  rpc getMessagesFilters (google.protobuf.Empty) returns (ListFilterName) {
  }

  /* gets all the names of sse event filters */

  rpc getEventsFilters (google.protobuf.Empty) returns (ListFilterName) {
  }

  /* gets filter info */

  rpc getEventFilterInfo (FilterName) returns (FilterInfo) {
  }

  /* gets filter info */

  rpc getMessageFilterInfo (FilterName) returns (FilterInfo) {
  }

  /* Checks that the event with the specified id is matched by the filter */

  rpc  matchEvent (MatchRequest) returns (IsMatched) {
  }

  /* Checks that the message with the specified id is matched by the filter */

  rpc  matchMessage (MatchRequest) returns (IsMatched) {
  }
}

/* Full event data */

message EventData {
  EventID event_id = 1; // Current event id
  EventID parent_event_id = 2; // Event id of a parent event. It is null for root event

  EventID batch_id = 3; // Event id of a parent event. It is null for root event

  bool is_batched = 4; // Flag indicating that the event is in batch

  google.protobuf.Timestamp start_timestamp = 5;
  google.protobuf.Timestamp end_timestamp = 6;
  EventStatus successful = 7; // Aggregated status of current and children events which sync written.
  string event_name = 8;
  string event_type = 9;
  bytes body = 10;
  repeated MessageID attached_message_ids = 11; // id of messages depending on this event
}

/* Event metadata */

message EventMetadata {
  EventID event_id = 1; // Current event id
  EventID parent_event_id = 2; // Event id of a parent event. It is null for root event

  google.protobuf.Timestamp start_timestamp = 4;
  EventStatus successful = 5; // Aggregated status of current and children events which sync written.
  string event_name = 6;
  string event_type = 7;
}

/* Full event data */

message MessageData {
  MessageID message_id = 1; // Message id should be unique in session
  ConnectionID session_id = 2; // Session alias
  Direction direction = 3; // Transport direction.
  google.protobuf.Timestamp timestamp = 4; // Message creation timestamp
  string message_type = 5; // Message type by dictionary
  string body = 6;
  string body_base64 = 7;
}

/* Message and last scanned object. With a certain frequency (this can be configured in the configuration options),

 * it is sent along with the elements found when searching via searchMessages */


message LastScannedObjectInfo {
  string id = 1; // Id of last scanned message or event
  int64 timestamp_millis = 2; // Timestamp of message or event
  int64 scan_counter = 3; // Number of objects already scanned
}

/* List of strings */

message StringList {
  repeated string list_string = 1;
}

/* Response of match request */

message IsMatched {
  bool is_matched = 1;
}

/* Filtering data types */

enum FilterParameterType {
  NUMBER = 0;
  BOOLEAN = 1;
  STRING = 2;
  STRING_LIST = 3;
}

message FilterName {
  string filter_name = 1;
}

message ListFilterName {
  repeated FilterName filter_names = 1;
}

message Parameter {
  string name = 1;
  FilterParameterType type = 2;
  google.protobuf.Any default_value = 3;
  string hint = 4;
}


/* Complete information about a specific filter */

message FilterInfo {
  FilterName name = 1;
  string hint = 2;
  repeated Parameter parameters = 3;
}

/* A filter object passed in a message or an event search request */


message Filter {
  FilterName name = 1;
  google.protobuf.BoolValue negative = 2;
  repeated string values = 3;
}

enum TimeRelation {
  NEXT = 0;
  PREVIOUS = 1;
}

/* The object containing the data of the last message in the stream on which
 * the search stopped, it is necessary to continue the search from the same place */


message Stream {
  string session = 1;
  Direction direction = 2;
  MessageID last_id = 3;
}

/* List of Stream containing information on all streams */

message StreamsInfo {
  repeated Stream streams = 1;
}

/* Checks that an event or a message with the specified id is matched by the filters */


message MatchRequest {
  oneof id {
    EventID event_id = 1;
    MessageID message_id = 2;
  }
  repeated Filter filters = 3;
}

/* Event search request */

message EventSearchRequest {
  google.protobuf.Timestamp start_timestamp = 1; // unix timestamp - Sets the search starting point. One of the 'start_timestamp' or 'resume_from_id' must not be null
  google.protobuf.Timestamp end_timestamp = 2; // unix timestamp - Sets the timestamp to which the search will be performed, starting with 'start_timestamp'. When 'search_direction' is previous, end_timestamp must be less than start_timestamp. It is set by default to null (the search is carried out endlessly into the past or into the future).

  EventID parent_event = 3; // Will match events with the specified parent element.
  TimeRelation search_direction = 4; // Sets the lookup direction. Can be used for pagination. Set by default to NEXT.

  EventID resume_from_id = 5; // last event id. In order to continue the execution of an interrupted sse request, you need to send exactly the same request with an indication of the element ID, from which the data transfer will be resumed. Set by default to null. One of the 'start_timestamp' or 'resume_from_id' must not be null

  google.protobuf.Int32Value result_count_limit = 6; // Sets the maximum amount of events to return. Set by default to 100.

  google.protobuf.BoolValue keep_open = 7; // If the search has reached the current moment, it is necessary to wait further for the appearance of new data. Set to false by default.

  google.protobuf.Int64Value limit_for_parent = 8; // How many children events for each parent do we want to request. Set by default to not limited.

  google.protobuf.BoolValue metadata_only = 9; //  Receive only metadata (true) or entire event (false) (without attachedMessageIds). Default true
  google.protobuf.BoolValue attached_messages = 10; // If the metadataOnly is false additionally load attachedMessageIds. Default false
  repeated Filter filters = 11; // List of event search filters. (See 'search/sse/events' HTTP method https://github.com/th2-net/th2-rpt-data-provider)
}

/* Message search request */

message MessageSearchRequest {
  google.protobuf.Timestamp start_timestamp = 1; // unix timestamp - Sets the search starting point. One of the 'start_timestamp' or 'resume_from_id' or 'message_id' must not be null
  google.protobuf.Timestamp end_timestamp = 2; // unix timestamp - Sets the timestamp to which the search will be performed, starting with 'start_timestamp'. When search_direction is 'previous', 'end_timestamp' must be less then 'start_timestamp'. Defaults to null (the search is carried out endlessly into the past or the future).
  MessageID resume_from_id = 3; // last message id. In order to continue the execution of an interrupted search request, you need to send exactly the same request with an indication of the element ID, from which to resume data transfer. Defaults to null. One of the 'start_timestamp' or 'resume_fromId' or 'message_id' must not be null
  TimeRelation search_direction = 4; // Sets the lookup direction. Can be used for pagination. Defaults to NEXT
  google.protobuf.Int32Value result_count_limit = 5; // Sets the maximum amount of messages to return. Defaults to 100
  StringList stream = 6; // Sets the stream ids to search in. Case-sensitive. Required.
  google.protobuf.BoolValue keep_open = 7; //  If the search has reached the current moment, is it necessary to wait further for the appearance of new data. Default false
  repeated MessageID message_id = 8; // List of message IDs to restore search. If given, it has the highest priority and ignores 'stream' (uses streams from ids), 'start_timestamp' and 'resume_fromId'. Defaults to null
  repeated Filter filters = 9; // List of message search filters. (See 'search/sse/message' HTTP method https://github.com/th2-net/th2-rpt-data-provider)
}

/* The object returned by the search function (searchMessages/searchEvents) */

message StreamResponse {
  oneof data {
    EventData event = 1;
    MessageData message = 2;
    EventMetadata event_metadata = 3;
    LastScannedObjectInfo last_scanned_object = 4;
    StreamsInfo stream_info = 5;
  }
}
